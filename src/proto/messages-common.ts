// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v5.27.2
// source: messages-common.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "hw.trezor.messages.common";

/**
 * Response: Success of the previous request
 * @end
 */
export interface Success {
  /** human readable description of action or request-specific payload */
  message?: string | undefined;
}

/**
 * Response: Failure of the previous request
 * @end
 */
export interface Failure {
  /** computer-readable definition of the error state */
  code?: Failure_FailureType | undefined;
  /** human-readable message of the error state */
  message?: string | undefined;
}

export enum Failure_FailureType {
  Failure_UnexpectedMessage = 1,
  Failure_ButtonExpected = 2,
  Failure_DataError = 3,
  Failure_ActionCancelled = 4,
  Failure_PinExpected = 5,
  Failure_PinCancelled = 6,
  Failure_PinInvalid = 7,
  Failure_InvalidSignature = 8,
  Failure_ProcessError = 9,
  Failure_NotEnoughFunds = 10,
  Failure_NotInitialized = 11,
  Failure_PinMismatch = 12,
  Failure_WipeCodeMismatch = 13,
  Failure_InvalidSession = 14,
  Failure_FirmwareError = 99,
  UNRECOGNIZED = -1,
}

export function failure_FailureTypeFromJSON(object: any): Failure_FailureType {
  switch (object) {
    case 1:
    case "Failure_UnexpectedMessage":
      return Failure_FailureType.Failure_UnexpectedMessage;
    case 2:
    case "Failure_ButtonExpected":
      return Failure_FailureType.Failure_ButtonExpected;
    case 3:
    case "Failure_DataError":
      return Failure_FailureType.Failure_DataError;
    case 4:
    case "Failure_ActionCancelled":
      return Failure_FailureType.Failure_ActionCancelled;
    case 5:
    case "Failure_PinExpected":
      return Failure_FailureType.Failure_PinExpected;
    case 6:
    case "Failure_PinCancelled":
      return Failure_FailureType.Failure_PinCancelled;
    case 7:
    case "Failure_PinInvalid":
      return Failure_FailureType.Failure_PinInvalid;
    case 8:
    case "Failure_InvalidSignature":
      return Failure_FailureType.Failure_InvalidSignature;
    case 9:
    case "Failure_ProcessError":
      return Failure_FailureType.Failure_ProcessError;
    case 10:
    case "Failure_NotEnoughFunds":
      return Failure_FailureType.Failure_NotEnoughFunds;
    case 11:
    case "Failure_NotInitialized":
      return Failure_FailureType.Failure_NotInitialized;
    case 12:
    case "Failure_PinMismatch":
      return Failure_FailureType.Failure_PinMismatch;
    case 13:
    case "Failure_WipeCodeMismatch":
      return Failure_FailureType.Failure_WipeCodeMismatch;
    case 14:
    case "Failure_InvalidSession":
      return Failure_FailureType.Failure_InvalidSession;
    case 99:
    case "Failure_FirmwareError":
      return Failure_FailureType.Failure_FirmwareError;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Failure_FailureType.UNRECOGNIZED;
  }
}

export function failure_FailureTypeToJSON(object: Failure_FailureType): string {
  switch (object) {
    case Failure_FailureType.Failure_UnexpectedMessage:
      return "Failure_UnexpectedMessage";
    case Failure_FailureType.Failure_ButtonExpected:
      return "Failure_ButtonExpected";
    case Failure_FailureType.Failure_DataError:
      return "Failure_DataError";
    case Failure_FailureType.Failure_ActionCancelled:
      return "Failure_ActionCancelled";
    case Failure_FailureType.Failure_PinExpected:
      return "Failure_PinExpected";
    case Failure_FailureType.Failure_PinCancelled:
      return "Failure_PinCancelled";
    case Failure_FailureType.Failure_PinInvalid:
      return "Failure_PinInvalid";
    case Failure_FailureType.Failure_InvalidSignature:
      return "Failure_InvalidSignature";
    case Failure_FailureType.Failure_ProcessError:
      return "Failure_ProcessError";
    case Failure_FailureType.Failure_NotEnoughFunds:
      return "Failure_NotEnoughFunds";
    case Failure_FailureType.Failure_NotInitialized:
      return "Failure_NotInitialized";
    case Failure_FailureType.Failure_PinMismatch:
      return "Failure_PinMismatch";
    case Failure_FailureType.Failure_WipeCodeMismatch:
      return "Failure_WipeCodeMismatch";
    case Failure_FailureType.Failure_InvalidSession:
      return "Failure_InvalidSession";
    case Failure_FailureType.Failure_FirmwareError:
      return "Failure_FirmwareError";
    case Failure_FailureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Response: Device is waiting for HW button press.
 * @auxstart
 * @next ButtonAck
 */
export interface ButtonRequest {
  /** enum identifier of the screen */
  code?: ButtonRequest_ButtonRequestType | undefined;
  /** if the screen is paginated, number of pages */
  pages?: number | undefined;
}

/** Type of button request */
export enum ButtonRequest_ButtonRequestType {
  ButtonRequest_Other = 1,
  ButtonRequest_FeeOverThreshold = 2,
  ButtonRequest_ConfirmOutput = 3,
  ButtonRequest_ResetDevice = 4,
  ButtonRequest_ConfirmWord = 5,
  ButtonRequest_WipeDevice = 6,
  ButtonRequest_ProtectCall = 7,
  ButtonRequest_SignTx = 8,
  ButtonRequest_FirmwareCheck = 9,
  ButtonRequest_Address = 10,
  ButtonRequest_PublicKey = 11,
  ButtonRequest_MnemonicWordCount = 12,
  ButtonRequest_MnemonicInput = 13,
  /** @deprecated */
  _Deprecated_ButtonRequest_PassphraseType = 14,
  ButtonRequest_UnknownDerivationPath = 15,
  ButtonRequest_RecoveryHomepage = 16,
  ButtonRequest_Success = 17,
  ButtonRequest_Warning = 18,
  ButtonRequest_PassphraseEntry = 19,
  ButtonRequest_PinEntry = 20,
  UNRECOGNIZED = -1,
}

export function buttonRequest_ButtonRequestTypeFromJSON(
  object: any,
): ButtonRequest_ButtonRequestType {
  switch (object) {
    case 1:
    case "ButtonRequest_Other":
      return ButtonRequest_ButtonRequestType.ButtonRequest_Other;
    case 2:
    case "ButtonRequest_FeeOverThreshold":
      return ButtonRequest_ButtonRequestType.ButtonRequest_FeeOverThreshold;
    case 3:
    case "ButtonRequest_ConfirmOutput":
      return ButtonRequest_ButtonRequestType.ButtonRequest_ConfirmOutput;
    case 4:
    case "ButtonRequest_ResetDevice":
      return ButtonRequest_ButtonRequestType.ButtonRequest_ResetDevice;
    case 5:
    case "ButtonRequest_ConfirmWord":
      return ButtonRequest_ButtonRequestType.ButtonRequest_ConfirmWord;
    case 6:
    case "ButtonRequest_WipeDevice":
      return ButtonRequest_ButtonRequestType.ButtonRequest_WipeDevice;
    case 7:
    case "ButtonRequest_ProtectCall":
      return ButtonRequest_ButtonRequestType.ButtonRequest_ProtectCall;
    case 8:
    case "ButtonRequest_SignTx":
      return ButtonRequest_ButtonRequestType.ButtonRequest_SignTx;
    case 9:
    case "ButtonRequest_FirmwareCheck":
      return ButtonRequest_ButtonRequestType.ButtonRequest_FirmwareCheck;
    case 10:
    case "ButtonRequest_Address":
      return ButtonRequest_ButtonRequestType.ButtonRequest_Address;
    case 11:
    case "ButtonRequest_PublicKey":
      return ButtonRequest_ButtonRequestType.ButtonRequest_PublicKey;
    case 12:
    case "ButtonRequest_MnemonicWordCount":
      return ButtonRequest_ButtonRequestType.ButtonRequest_MnemonicWordCount;
    case 13:
    case "ButtonRequest_MnemonicInput":
      return ButtonRequest_ButtonRequestType.ButtonRequest_MnemonicInput;
    case 14:
    case "_Deprecated_ButtonRequest_PassphraseType":
      return ButtonRequest_ButtonRequestType._Deprecated_ButtonRequest_PassphraseType;
    case 15:
    case "ButtonRequest_UnknownDerivationPath":
      return ButtonRequest_ButtonRequestType.ButtonRequest_UnknownDerivationPath;
    case 16:
    case "ButtonRequest_RecoveryHomepage":
      return ButtonRequest_ButtonRequestType.ButtonRequest_RecoveryHomepage;
    case 17:
    case "ButtonRequest_Success":
      return ButtonRequest_ButtonRequestType.ButtonRequest_Success;
    case 18:
    case "ButtonRequest_Warning":
      return ButtonRequest_ButtonRequestType.ButtonRequest_Warning;
    case 19:
    case "ButtonRequest_PassphraseEntry":
      return ButtonRequest_ButtonRequestType.ButtonRequest_PassphraseEntry;
    case 20:
    case "ButtonRequest_PinEntry":
      return ButtonRequest_ButtonRequestType.ButtonRequest_PinEntry;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ButtonRequest_ButtonRequestType.UNRECOGNIZED;
  }
}

export function buttonRequest_ButtonRequestTypeToJSON(
  object: ButtonRequest_ButtonRequestType,
): string {
  switch (object) {
    case ButtonRequest_ButtonRequestType.ButtonRequest_Other:
      return "ButtonRequest_Other";
    case ButtonRequest_ButtonRequestType.ButtonRequest_FeeOverThreshold:
      return "ButtonRequest_FeeOverThreshold";
    case ButtonRequest_ButtonRequestType.ButtonRequest_ConfirmOutput:
      return "ButtonRequest_ConfirmOutput";
    case ButtonRequest_ButtonRequestType.ButtonRequest_ResetDevice:
      return "ButtonRequest_ResetDevice";
    case ButtonRequest_ButtonRequestType.ButtonRequest_ConfirmWord:
      return "ButtonRequest_ConfirmWord";
    case ButtonRequest_ButtonRequestType.ButtonRequest_WipeDevice:
      return "ButtonRequest_WipeDevice";
    case ButtonRequest_ButtonRequestType.ButtonRequest_ProtectCall:
      return "ButtonRequest_ProtectCall";
    case ButtonRequest_ButtonRequestType.ButtonRequest_SignTx:
      return "ButtonRequest_SignTx";
    case ButtonRequest_ButtonRequestType.ButtonRequest_FirmwareCheck:
      return "ButtonRequest_FirmwareCheck";
    case ButtonRequest_ButtonRequestType.ButtonRequest_Address:
      return "ButtonRequest_Address";
    case ButtonRequest_ButtonRequestType.ButtonRequest_PublicKey:
      return "ButtonRequest_PublicKey";
    case ButtonRequest_ButtonRequestType.ButtonRequest_MnemonicWordCount:
      return "ButtonRequest_MnemonicWordCount";
    case ButtonRequest_ButtonRequestType.ButtonRequest_MnemonicInput:
      return "ButtonRequest_MnemonicInput";
    case ButtonRequest_ButtonRequestType._Deprecated_ButtonRequest_PassphraseType:
      return "_Deprecated_ButtonRequest_PassphraseType";
    case ButtonRequest_ButtonRequestType.ButtonRequest_UnknownDerivationPath:
      return "ButtonRequest_UnknownDerivationPath";
    case ButtonRequest_ButtonRequestType.ButtonRequest_RecoveryHomepage:
      return "ButtonRequest_RecoveryHomepage";
    case ButtonRequest_ButtonRequestType.ButtonRequest_Success:
      return "ButtonRequest_Success";
    case ButtonRequest_ButtonRequestType.ButtonRequest_Warning:
      return "ButtonRequest_Warning";
    case ButtonRequest_ButtonRequestType.ButtonRequest_PassphraseEntry:
      return "ButtonRequest_PassphraseEntry";
    case ButtonRequest_ButtonRequestType.ButtonRequest_PinEntry:
      return "ButtonRequest_PinEntry";
    case ButtonRequest_ButtonRequestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Request: Computer agrees to wait for HW button press
 * @auxend
 */
export interface ButtonAck {}

/**
 * Response: Device is asking computer to show PIN matrix and awaits PIN encoded using this matrix scheme
 * @auxstart
 * @next PinMatrixAck
 */
export interface PinMatrixRequest {
  type?: PinMatrixRequest_PinMatrixRequestType | undefined;
}

/** Type of PIN request */
export enum PinMatrixRequest_PinMatrixRequestType {
  PinMatrixRequestType_Current = 1,
  PinMatrixRequestType_NewFirst = 2,
  PinMatrixRequestType_NewSecond = 3,
  PinMatrixRequestType_WipeCodeFirst = 4,
  PinMatrixRequestType_WipeCodeSecond = 5,
  UNRECOGNIZED = -1,
}

export function pinMatrixRequest_PinMatrixRequestTypeFromJSON(
  object: any,
): PinMatrixRequest_PinMatrixRequestType {
  switch (object) {
    case 1:
    case "PinMatrixRequestType_Current":
      return PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_Current;
    case 2:
    case "PinMatrixRequestType_NewFirst":
      return PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_NewFirst;
    case 3:
    case "PinMatrixRequestType_NewSecond":
      return PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_NewSecond;
    case 4:
    case "PinMatrixRequestType_WipeCodeFirst":
      return PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_WipeCodeFirst;
    case 5:
    case "PinMatrixRequestType_WipeCodeSecond":
      return PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_WipeCodeSecond;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PinMatrixRequest_PinMatrixRequestType.UNRECOGNIZED;
  }
}

export function pinMatrixRequest_PinMatrixRequestTypeToJSON(
  object: PinMatrixRequest_PinMatrixRequestType,
): string {
  switch (object) {
    case PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_Current:
      return "PinMatrixRequestType_Current";
    case PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_NewFirst:
      return "PinMatrixRequestType_NewFirst";
    case PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_NewSecond:
      return "PinMatrixRequestType_NewSecond";
    case PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_WipeCodeFirst:
      return "PinMatrixRequestType_WipeCodeFirst";
    case PinMatrixRequest_PinMatrixRequestType.PinMatrixRequestType_WipeCodeSecond:
      return "PinMatrixRequestType_WipeCodeSecond";
    case PinMatrixRequest_PinMatrixRequestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Request: Computer responds with encoded PIN
 * @auxend
 */
export interface PinMatrixAck {
  /** matrix encoded PIN entered by user */
  pin: string;
}

/**
 * Response: Device awaits encryption passphrase
 * @auxstart
 * @next PassphraseAck
 */
export interface PassphraseRequest {
  /**
   * <2.3.0
   *
   * @deprecated
   */
  OnDevice?: boolean | undefined;
}

/**
 * Request: Send passphrase back
 * @auxend
 */
export interface PassphraseAck {
  passphrase?: string | undefined;
  /**
   * <2.3.0
   *
   * @deprecated
   */
  State?: Uint8Array | undefined;
  /** user wants to enter passphrase on the device */
  onDevice?: boolean | undefined;
}

/**
 * Response: Device awaits passphrase state
 * Deprecated in 2.3.0
 * @next Deprecated_PassphraseStateAck
 *
 * @deprecated
 */
export interface DeprecatedPassphraseStateRequest {
  /** actual device state */
  state?: Uint8Array | undefined;
}

/**
 * Request: Send passphrase state back
 * Deprecated in 2.3.0
 * @auxend
 *
 * @deprecated
 */
export interface DeprecatedPassphraseStateAck {}

/**
 * Structure representing BIP32 (hierarchical deterministic) node
 * Used for imports of private key into the device and exporting public key out of device
 * @embed
 */
export interface HDNodeType {
  depth: number;
  fingerprint: number;
  childNum: number;
  chainCode: Uint8Array;
  privateKey?: Uint8Array | undefined;
  publicKey: Uint8Array;
}

function createBaseSuccess(): Success {
  return { message: "" };
}

export const Success = {
  encode(
    message: Success,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Success {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Success {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Success): unknown {
    const obj: any = {};
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Success>, I>>(base?: I): Success {
    return Success.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Success>, I>>(object: I): Success {
    const message = createBaseSuccess();
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseFailure(): Failure {
  return { code: 1, message: "" };
}

export const Failure = {
  encode(
    message: Failure,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.code !== undefined && message.code !== 1) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Failure {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Failure {
    return {
      code: isSet(object.code) ? failure_FailureTypeFromJSON(object.code) : 1,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Failure): unknown {
    const obj: any = {};
    if (message.code !== undefined && message.code !== 1) {
      obj.code = failure_FailureTypeToJSON(message.code);
    }
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Failure>, I>>(base?: I): Failure {
    return Failure.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Failure>, I>>(object: I): Failure {
    const message = createBaseFailure();
    message.code = object.code ?? 1;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseButtonRequest(): ButtonRequest {
  return { code: 1, pages: 0 };
}

export const ButtonRequest = {
  encode(
    message: ButtonRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.code !== undefined && message.code !== 1) {
      writer.uint32(8).int32(message.code);
    }
    if (message.pages !== undefined && message.pages !== 0) {
      writer.uint32(16).uint32(message.pages);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ButtonRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButtonRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pages = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ButtonRequest {
    return {
      code: isSet(object.code)
        ? buttonRequest_ButtonRequestTypeFromJSON(object.code)
        : 1,
      pages: isSet(object.pages) ? globalThis.Number(object.pages) : 0,
    };
  },

  toJSON(message: ButtonRequest): unknown {
    const obj: any = {};
    if (message.code !== undefined && message.code !== 1) {
      obj.code = buttonRequest_ButtonRequestTypeToJSON(message.code);
    }
    if (message.pages !== undefined && message.pages !== 0) {
      obj.pages = Math.round(message.pages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ButtonRequest>, I>>(
    base?: I,
  ): ButtonRequest {
    return ButtonRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ButtonRequest>, I>>(
    object: I,
  ): ButtonRequest {
    const message = createBaseButtonRequest();
    message.code = object.code ?? 1;
    message.pages = object.pages ?? 0;
    return message;
  },
};

function createBaseButtonAck(): ButtonAck {
  return {};
}

export const ButtonAck = {
  encode(_: ButtonAck, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ButtonAck {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseButtonAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ButtonAck {
    return {};
  },

  toJSON(_: ButtonAck): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ButtonAck>, I>>(base?: I): ButtonAck {
    return ButtonAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ButtonAck>, I>>(_: I): ButtonAck {
    const message = createBaseButtonAck();
    return message;
  },
};

function createBasePinMatrixRequest(): PinMatrixRequest {
  return { type: 1 };
}

export const PinMatrixRequest = {
  encode(
    message: PinMatrixRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.type !== undefined && message.type !== 1) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PinMatrixRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinMatrixRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinMatrixRequest {
    return {
      type: isSet(object.type)
        ? pinMatrixRequest_PinMatrixRequestTypeFromJSON(object.type)
        : 1,
    };
  },

  toJSON(message: PinMatrixRequest): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== 1) {
      obj.type = pinMatrixRequest_PinMatrixRequestTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PinMatrixRequest>, I>>(
    base?: I,
  ): PinMatrixRequest {
    return PinMatrixRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PinMatrixRequest>, I>>(
    object: I,
  ): PinMatrixRequest {
    const message = createBasePinMatrixRequest();
    message.type = object.type ?? 1;
    return message;
  },
};

function createBasePinMatrixAck(): PinMatrixAck {
  return { pin: "" };
}

export const PinMatrixAck = {
  encode(
    message: PinMatrixAck,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.pin !== "") {
      writer.uint32(10).string(message.pin);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PinMatrixAck {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePinMatrixAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pin = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PinMatrixAck {
    return { pin: isSet(object.pin) ? globalThis.String(object.pin) : "" };
  },

  toJSON(message: PinMatrixAck): unknown {
    const obj: any = {};
    if (message.pin !== "") {
      obj.pin = message.pin;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PinMatrixAck>, I>>(
    base?: I,
  ): PinMatrixAck {
    return PinMatrixAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PinMatrixAck>, I>>(
    object: I,
  ): PinMatrixAck {
    const message = createBasePinMatrixAck();
    message.pin = object.pin ?? "";
    return message;
  },
};

function createBasePassphraseRequest(): PassphraseRequest {
  return { OnDevice: false };
}

export const PassphraseRequest = {
  encode(
    message: PassphraseRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.OnDevice !== undefined && message.OnDevice !== false) {
      writer.uint32(8).bool(message.OnDevice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PassphraseRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePassphraseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.OnDevice = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PassphraseRequest {
    return {
      OnDevice: isSet(object.OnDevice)
        ? globalThis.Boolean(object.OnDevice)
        : false,
    };
  },

  toJSON(message: PassphraseRequest): unknown {
    const obj: any = {};
    if (message.OnDevice !== undefined && message.OnDevice !== false) {
      obj.OnDevice = message.OnDevice;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PassphraseRequest>, I>>(
    base?: I,
  ): PassphraseRequest {
    return PassphraseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PassphraseRequest>, I>>(
    object: I,
  ): PassphraseRequest {
    const message = createBasePassphraseRequest();
    message.OnDevice = object.OnDevice ?? false;
    return message;
  },
};

function createBasePassphraseAck(): PassphraseAck {
  return { passphrase: "", State: new Uint8Array(0), onDevice: false };
}

export const PassphraseAck = {
  encode(
    message: PassphraseAck,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.passphrase !== undefined && message.passphrase !== "") {
      writer.uint32(10).string(message.passphrase);
    }
    if (message.State !== undefined && message.State.length !== 0) {
      writer.uint32(18).bytes(message.State);
    }
    if (message.onDevice !== undefined && message.onDevice !== false) {
      writer.uint32(24).bool(message.onDevice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PassphraseAck {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePassphraseAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.passphrase = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.State = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.onDevice = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PassphraseAck {
    return {
      passphrase: isSet(object.passphrase)
        ? globalThis.String(object.passphrase)
        : "",
      State: isSet(object.State)
        ? bytesFromBase64(object.State)
        : new Uint8Array(0),
      onDevice: isSet(object.onDevice)
        ? globalThis.Boolean(object.onDevice)
        : false,
    };
  },

  toJSON(message: PassphraseAck): unknown {
    const obj: any = {};
    if (message.passphrase !== undefined && message.passphrase !== "") {
      obj.passphrase = message.passphrase;
    }
    if (message.State !== undefined && message.State.length !== 0) {
      obj.State = base64FromBytes(message.State);
    }
    if (message.onDevice !== undefined && message.onDevice !== false) {
      obj.onDevice = message.onDevice;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PassphraseAck>, I>>(
    base?: I,
  ): PassphraseAck {
    return PassphraseAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PassphraseAck>, I>>(
    object: I,
  ): PassphraseAck {
    const message = createBasePassphraseAck();
    message.passphrase = object.passphrase ?? "";
    message.State = object.State ?? new Uint8Array(0);
    message.onDevice = object.onDevice ?? false;
    return message;
  },
};

function createBaseDeprecatedPassphraseStateRequest(): DeprecatedPassphraseStateRequest {
  return { state: new Uint8Array(0) };
}

export const DeprecatedPassphraseStateRequest = {
  encode(
    message: DeprecatedPassphraseStateRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.state !== undefined && message.state.length !== 0) {
      writer.uint32(10).bytes(message.state);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): DeprecatedPassphraseStateRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeprecatedPassphraseStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeprecatedPassphraseStateRequest {
    return {
      state: isSet(object.state)
        ? bytesFromBase64(object.state)
        : new Uint8Array(0),
    };
  },

  toJSON(message: DeprecatedPassphraseStateRequest): unknown {
    const obj: any = {};
    if (message.state !== undefined && message.state.length !== 0) {
      obj.state = base64FromBytes(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeprecatedPassphraseStateRequest>, I>>(
    base?: I,
  ): DeprecatedPassphraseStateRequest {
    return DeprecatedPassphraseStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<
    I extends Exact<DeepPartial<DeprecatedPassphraseStateRequest>, I>,
  >(object: I): DeprecatedPassphraseStateRequest {
    const message = createBaseDeprecatedPassphraseStateRequest();
    message.state = object.state ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDeprecatedPassphraseStateAck(): DeprecatedPassphraseStateAck {
  return {};
}

export const DeprecatedPassphraseStateAck = {
  encode(
    _: DeprecatedPassphraseStateAck,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): DeprecatedPassphraseStateAck {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeprecatedPassphraseStateAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeprecatedPassphraseStateAck {
    return {};
  },

  toJSON(_: DeprecatedPassphraseStateAck): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DeprecatedPassphraseStateAck>, I>>(
    base?: I,
  ): DeprecatedPassphraseStateAck {
    return DeprecatedPassphraseStateAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeprecatedPassphraseStateAck>, I>>(
    _: I,
  ): DeprecatedPassphraseStateAck {
    const message = createBaseDeprecatedPassphraseStateAck();
    return message;
  },
};

function createBaseHDNodeType(): HDNodeType {
  return {
    depth: 0,
    fingerprint: 0,
    childNum: 0,
    chainCode: new Uint8Array(0),
    privateKey: new Uint8Array(0),
    publicKey: new Uint8Array(0),
  };
}

export const HDNodeType = {
  encode(
    message: HDNodeType,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.depth !== 0) {
      writer.uint32(8).uint32(message.depth);
    }
    if (message.fingerprint !== 0) {
      writer.uint32(16).uint32(message.fingerprint);
    }
    if (message.childNum !== 0) {
      writer.uint32(24).uint32(message.childNum);
    }
    if (message.chainCode.length !== 0) {
      writer.uint32(34).bytes(message.chainCode);
    }
    if (message.privateKey !== undefined && message.privateKey.length !== 0) {
      writer.uint32(42).bytes(message.privateKey);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(50).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HDNodeType {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHDNodeType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.depth = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fingerprint = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.childNum = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.chainCode = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.privateKey = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HDNodeType {
    return {
      depth: isSet(object.depth) ? globalThis.Number(object.depth) : 0,
      fingerprint: isSet(object.fingerprint)
        ? globalThis.Number(object.fingerprint)
        : 0,
      childNum: isSet(object.childNum) ? globalThis.Number(object.childNum) : 0,
      chainCode: isSet(object.chainCode)
        ? bytesFromBase64(object.chainCode)
        : new Uint8Array(0),
      privateKey: isSet(object.privateKey)
        ? bytesFromBase64(object.privateKey)
        : new Uint8Array(0),
      publicKey: isSet(object.publicKey)
        ? bytesFromBase64(object.publicKey)
        : new Uint8Array(0),
    };
  },

  toJSON(message: HDNodeType): unknown {
    const obj: any = {};
    if (message.depth !== 0) {
      obj.depth = Math.round(message.depth);
    }
    if (message.fingerprint !== 0) {
      obj.fingerprint = Math.round(message.fingerprint);
    }
    if (message.childNum !== 0) {
      obj.childNum = Math.round(message.childNum);
    }
    if (message.chainCode.length !== 0) {
      obj.chainCode = base64FromBytes(message.chainCode);
    }
    if (message.privateKey !== undefined && message.privateKey.length !== 0) {
      obj.privateKey = base64FromBytes(message.privateKey);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HDNodeType>, I>>(base?: I): HDNodeType {
    return HDNodeType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HDNodeType>, I>>(
    object: I,
  ): HDNodeType {
    const message = createBaseHDNodeType();
    message.depth = object.depth ?? 0;
    message.fingerprint = object.fingerprint ?? 0;
    message.childNum = object.childNum ?? 0;
    message.chainCode = object.chainCode ?? new Uint8Array(0);
    message.privateKey = object.privateKey ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
