// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v5.27.2
// source: messages-ethereum-eip712.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { EthereumDefinitions } from "./messages-ethereum-definitions";

export const protobufPackage = "hw.trezor.messages.ethereum_eip712";

/**
 * Request: Ask device to sign typed data
 * @start
 * @next EthereumTypedDataStructRequest
 * @next EthereumTypedDataValueRequest
 * @next EthereumTypedDataSignature
 * @next Failure
 */
export interface EthereumSignTypedData {
  /** BIP-32 path to derive the key from master node */
  addressN: number[];
  /** name of the root message struct */
  primaryType: string;
  /** use MetaMask v4 (see https://github.com/MetaMask/eth-sig-util/issues/106) */
  metamaskV4Compat?: boolean | undefined;
  /** network and/or token definitions */
  definitions?: EthereumDefinitions | undefined;
}

/**
 * Response: Device asks for type information about a struct.
 * @next EthereumTypedDataStructAck
 */
export interface EthereumTypedDataStructRequest {
  /** name of the requested struct */
  name: string;
}

/**
 * Request: Type information about a struct.
 * @next EthereumTypedDataStructRequest
 */
export interface EthereumTypedDataStructAck {
  members: EthereumTypedDataStructAck_EthereumStructMember[];
}

export enum EthereumTypedDataStructAck_EthereumDataType {
  UINT = 1,
  INT = 2,
  BYTES = 3,
  STRING = 4,
  BOOL = 5,
  ADDRESS = 6,
  ARRAY = 7,
  STRUCT = 8,
  UNRECOGNIZED = -1,
}

export function ethereumTypedDataStructAck_EthereumDataTypeFromJSON(
  object: any,
): EthereumTypedDataStructAck_EthereumDataType {
  switch (object) {
    case 1:
    case "UINT":
      return EthereumTypedDataStructAck_EthereumDataType.UINT;
    case 2:
    case "INT":
      return EthereumTypedDataStructAck_EthereumDataType.INT;
    case 3:
    case "BYTES":
      return EthereumTypedDataStructAck_EthereumDataType.BYTES;
    case 4:
    case "STRING":
      return EthereumTypedDataStructAck_EthereumDataType.STRING;
    case 5:
    case "BOOL":
      return EthereumTypedDataStructAck_EthereumDataType.BOOL;
    case 6:
    case "ADDRESS":
      return EthereumTypedDataStructAck_EthereumDataType.ADDRESS;
    case 7:
    case "ARRAY":
      return EthereumTypedDataStructAck_EthereumDataType.ARRAY;
    case 8:
    case "STRUCT":
      return EthereumTypedDataStructAck_EthereumDataType.STRUCT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EthereumTypedDataStructAck_EthereumDataType.UNRECOGNIZED;
  }
}

export function ethereumTypedDataStructAck_EthereumDataTypeToJSON(
  object: EthereumTypedDataStructAck_EthereumDataType,
): string {
  switch (object) {
    case EthereumTypedDataStructAck_EthereumDataType.UINT:
      return "UINT";
    case EthereumTypedDataStructAck_EthereumDataType.INT:
      return "INT";
    case EthereumTypedDataStructAck_EthereumDataType.BYTES:
      return "BYTES";
    case EthereumTypedDataStructAck_EthereumDataType.STRING:
      return "STRING";
    case EthereumTypedDataStructAck_EthereumDataType.BOOL:
      return "BOOL";
    case EthereumTypedDataStructAck_EthereumDataType.ADDRESS:
      return "ADDRESS";
    case EthereumTypedDataStructAck_EthereumDataType.ARRAY:
      return "ARRAY";
    case EthereumTypedDataStructAck_EthereumDataType.STRUCT:
      return "STRUCT";
    case EthereumTypedDataStructAck_EthereumDataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EthereumTypedDataStructAck_EthereumStructMember {
  type: EthereumTypedDataStructAck_EthereumFieldType | undefined;
  name: string;
}

export interface EthereumTypedDataStructAck_EthereumFieldType {
  dataType: EthereumTypedDataStructAck_EthereumDataType;
  /** for integer types: size in bytes (uint8 has size 1, uint256 has size 32) */
  size?: number | undefined;
  /**
   * for bytes types: size in bytes, or unset for dynamic
   * for arrays: size in elements, or unset for dynamic
   * for structs: number of members
   * for string, bool and address: unset
   */
  entryType?: EthereumTypedDataStructAck_EthereumFieldType | undefined;
  /** for structs: its name */
  structName?: string | undefined;
}

/**
 * Response: Device asks for data at the specific member path.
 * @next EthereumTypedDataValueAck
 */
export interface EthereumTypedDataValueRequest {
  /** member path requested by device */
  memberPath: number[];
}

/**
 * Request: Single value of a specific atomic field.
 * @next EthereumTypedDataValueRequest
 */
export interface EthereumTypedDataValueAck {
  /**
   * atomic types: value of the member.
   *   Length must match the `size` of the corresponding field type, unless the size is dynamic.
   * * array types: number of elements, encoded as uint16.
   * * struct types: undefined, Trezor will not query a struct field.
   */
  value: Uint8Array;
}

function createBaseEthereumSignTypedData(): EthereumSignTypedData {
  return {
    addressN: [],
    primaryType: "",
    metamaskV4Compat: true,
    definitions: undefined,
  };
}

export const EthereumSignTypedData = {
  encode(
    message: EthereumSignTypedData,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.addressN) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.primaryType !== "") {
      writer.uint32(18).string(message.primaryType);
    }
    if (
      message.metamaskV4Compat !== undefined &&
      message.metamaskV4Compat !== true
    ) {
      writer.uint32(24).bool(message.metamaskV4Compat);
    }
    if (message.definitions !== undefined) {
      EthereumDefinitions.encode(
        message.definitions,
        writer.uint32(34).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumSignTypedData {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumSignTypedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.addressN.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressN.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.primaryType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.metamaskV4Compat = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.definitions = EthereumDefinitions.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumSignTypedData {
    return {
      addressN: globalThis.Array.isArray(object?.addressN)
        ? object.addressN.map((e: any) => globalThis.Number(e))
        : [],
      primaryType: isSet(object.primaryType)
        ? globalThis.String(object.primaryType)
        : "",
      metamaskV4Compat: isSet(object.metamaskV4Compat)
        ? globalThis.Boolean(object.metamaskV4Compat)
        : true,
      definitions: isSet(object.definitions)
        ? EthereumDefinitions.fromJSON(object.definitions)
        : undefined,
    };
  },

  toJSON(message: EthereumSignTypedData): unknown {
    const obj: any = {};
    if (message.addressN?.length) {
      obj.addressN = message.addressN.map((e) => Math.round(e));
    }
    if (message.primaryType !== "") {
      obj.primaryType = message.primaryType;
    }
    if (
      message.metamaskV4Compat !== undefined &&
      message.metamaskV4Compat !== true
    ) {
      obj.metamaskV4Compat = message.metamaskV4Compat;
    }
    if (message.definitions !== undefined) {
      obj.definitions = EthereumDefinitions.toJSON(message.definitions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumSignTypedData>, I>>(
    base?: I,
  ): EthereumSignTypedData {
    return EthereumSignTypedData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumSignTypedData>, I>>(
    object: I,
  ): EthereumSignTypedData {
    const message = createBaseEthereumSignTypedData();
    message.addressN = object.addressN?.map((e) => e) || [];
    message.primaryType = object.primaryType ?? "";
    message.metamaskV4Compat = object.metamaskV4Compat ?? true;
    message.definitions =
      object.definitions !== undefined && object.definitions !== null
        ? EthereumDefinitions.fromPartial(object.definitions)
        : undefined;
    return message;
  },
};

function createBaseEthereumTypedDataStructRequest(): EthereumTypedDataStructRequest {
  return { name: "" };
}

export const EthereumTypedDataStructRequest = {
  encode(
    message: EthereumTypedDataStructRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumTypedDataStructRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTypedDataStructRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTypedDataStructRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: EthereumTypedDataStructRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumTypedDataStructRequest>, I>>(
    base?: I,
  ): EthereumTypedDataStructRequest {
    return EthereumTypedDataStructRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumTypedDataStructRequest>, I>>(
    object: I,
  ): EthereumTypedDataStructRequest {
    const message = createBaseEthereumTypedDataStructRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseEthereumTypedDataStructAck(): EthereumTypedDataStructAck {
  return { members: [] };
}

export const EthereumTypedDataStructAck = {
  encode(
    message: EthereumTypedDataStructAck,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.members) {
      EthereumTypedDataStructAck_EthereumStructMember.encode(
        v!,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumTypedDataStructAck {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTypedDataStructAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.members.push(
            EthereumTypedDataStructAck_EthereumStructMember.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTypedDataStructAck {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) =>
            EthereumTypedDataStructAck_EthereumStructMember.fromJSON(e),
          )
        : [],
    };
  },

  toJSON(message: EthereumTypedDataStructAck): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) =>
        EthereumTypedDataStructAck_EthereumStructMember.toJSON(e),
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumTypedDataStructAck>, I>>(
    base?: I,
  ): EthereumTypedDataStructAck {
    return EthereumTypedDataStructAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumTypedDataStructAck>, I>>(
    object: I,
  ): EthereumTypedDataStructAck {
    const message = createBaseEthereumTypedDataStructAck();
    message.members =
      object.members?.map((e) =>
        EthereumTypedDataStructAck_EthereumStructMember.fromPartial(e),
      ) || [];
    return message;
  },
};

function createBaseEthereumTypedDataStructAck_EthereumStructMember(): EthereumTypedDataStructAck_EthereumStructMember {
  return { type: undefined, name: "" };
}

export const EthereumTypedDataStructAck_EthereumStructMember = {
  encode(
    message: EthereumTypedDataStructAck_EthereumStructMember,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.type !== undefined) {
      EthereumTypedDataStructAck_EthereumFieldType.encode(
        message.type,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumTypedDataStructAck_EthereumStructMember {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTypedDataStructAck_EthereumStructMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = EthereumTypedDataStructAck_EthereumFieldType.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTypedDataStructAck_EthereumStructMember {
    return {
      type: isSet(object.type)
        ? EthereumTypedDataStructAck_EthereumFieldType.fromJSON(object.type)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: EthereumTypedDataStructAck_EthereumStructMember): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = EthereumTypedDataStructAck_EthereumFieldType.toJSON(
        message.type,
      );
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<
    I extends Exact<
      DeepPartial<EthereumTypedDataStructAck_EthereumStructMember>,
      I
    >,
  >(base?: I): EthereumTypedDataStructAck_EthereumStructMember {
    return EthereumTypedDataStructAck_EthereumStructMember.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<
      DeepPartial<EthereumTypedDataStructAck_EthereumStructMember>,
      I
    >,
  >(object: I): EthereumTypedDataStructAck_EthereumStructMember {
    const message = createBaseEthereumTypedDataStructAck_EthereumStructMember();
    message.type =
      object.type !== undefined && object.type !== null
        ? EthereumTypedDataStructAck_EthereumFieldType.fromPartial(object.type)
        : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseEthereumTypedDataStructAck_EthereumFieldType(): EthereumTypedDataStructAck_EthereumFieldType {
  return { dataType: 1, size: 0, entryType: undefined, structName: "" };
}

export const EthereumTypedDataStructAck_EthereumFieldType = {
  encode(
    message: EthereumTypedDataStructAck_EthereumFieldType,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.dataType !== 1) {
      writer.uint32(8).int32(message.dataType);
    }
    if (message.size !== undefined && message.size !== 0) {
      writer.uint32(16).uint32(message.size);
    }
    if (message.entryType !== undefined) {
      EthereumTypedDataStructAck_EthereumFieldType.encode(
        message.entryType,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    if (message.structName !== undefined && message.structName !== "") {
      writer.uint32(34).string(message.structName);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumTypedDataStructAck_EthereumFieldType {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTypedDataStructAck_EthereumFieldType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.size = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryType =
            EthereumTypedDataStructAck_EthereumFieldType.decode(
              reader,
              reader.uint32(),
            );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.structName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTypedDataStructAck_EthereumFieldType {
    return {
      dataType: isSet(object.dataType)
        ? ethereumTypedDataStructAck_EthereumDataTypeFromJSON(object.dataType)
        : 1,
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      entryType: isSet(object.entryType)
        ? EthereumTypedDataStructAck_EthereumFieldType.fromJSON(
            object.entryType,
          )
        : undefined,
      structName: isSet(object.structName)
        ? globalThis.String(object.structName)
        : "",
    };
  },

  toJSON(message: EthereumTypedDataStructAck_EthereumFieldType): unknown {
    const obj: any = {};
    if (message.dataType !== 1) {
      obj.dataType = ethereumTypedDataStructAck_EthereumDataTypeToJSON(
        message.dataType,
      );
    }
    if (message.size !== undefined && message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.entryType !== undefined) {
      obj.entryType = EthereumTypedDataStructAck_EthereumFieldType.toJSON(
        message.entryType,
      );
    }
    if (message.structName !== undefined && message.structName !== "") {
      obj.structName = message.structName;
    }
    return obj;
  },

  create<
    I extends Exact<
      DeepPartial<EthereumTypedDataStructAck_EthereumFieldType>,
      I
    >,
  >(base?: I): EthereumTypedDataStructAck_EthereumFieldType {
    return EthereumTypedDataStructAck_EthereumFieldType.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<
      DeepPartial<EthereumTypedDataStructAck_EthereumFieldType>,
      I
    >,
  >(object: I): EthereumTypedDataStructAck_EthereumFieldType {
    const message = createBaseEthereumTypedDataStructAck_EthereumFieldType();
    message.dataType = object.dataType ?? 1;
    message.size = object.size ?? 0;
    message.entryType =
      object.entryType !== undefined && object.entryType !== null
        ? EthereumTypedDataStructAck_EthereumFieldType.fromPartial(
            object.entryType,
          )
        : undefined;
    message.structName = object.structName ?? "";
    return message;
  },
};

function createBaseEthereumTypedDataValueRequest(): EthereumTypedDataValueRequest {
  return { memberPath: [] };
}

export const EthereumTypedDataValueRequest = {
  encode(
    message: EthereumTypedDataValueRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.memberPath) {
      writer.uint32(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumTypedDataValueRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTypedDataValueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.memberPath.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.memberPath.push(reader.uint32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTypedDataValueRequest {
    return {
      memberPath: globalThis.Array.isArray(object?.memberPath)
        ? object.memberPath.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: EthereumTypedDataValueRequest): unknown {
    const obj: any = {};
    if (message.memberPath?.length) {
      obj.memberPath = message.memberPath.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumTypedDataValueRequest>, I>>(
    base?: I,
  ): EthereumTypedDataValueRequest {
    return EthereumTypedDataValueRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumTypedDataValueRequest>, I>>(
    object: I,
  ): EthereumTypedDataValueRequest {
    const message = createBaseEthereumTypedDataValueRequest();
    message.memberPath = object.memberPath?.map((e) => e) || [];
    return message;
  },
};

function createBaseEthereumTypedDataValueAck(): EthereumTypedDataValueAck {
  return { value: new Uint8Array(0) };
}

export const EthereumTypedDataValueAck = {
  encode(
    message: EthereumTypedDataValueAck,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.value.length !== 0) {
      writer.uint32(10).bytes(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumTypedDataValueAck {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTypedDataValueAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTypedDataValueAck {
    return {
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
    };
  },

  toJSON(message: EthereumTypedDataValueAck): unknown {
    const obj: any = {};
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumTypedDataValueAck>, I>>(
    base?: I,
  ): EthereumTypedDataValueAck {
    return EthereumTypedDataValueAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumTypedDataValueAck>, I>>(
    object: I,
  ): EthereumTypedDataValueAck {
    const message = createBaseEthereumTypedDataValueAck();
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
