// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v5.27.2
// source: messages-ethereum.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { HDNodeType } from "./messages-common";
import { EthereumDefinitions } from "./messages-ethereum-definitions";
import Long = require("long");

export const protobufPackage = "hw.trezor.messages.ethereum";

/**
 * Request: Ask device for public key corresponding to address_n path
 * @start
 * @next EthereumPublicKey
 * @next Failure
 */
export interface EthereumGetPublicKey {
  /** BIP-32 path to derive the key from master node */
  addressN: number[];
  /** optionally show on display before sending the result */
  showDisplay?: boolean | undefined;
}

/**
 * Response: Contains public key derived from device private seed
 * @end
 */
export interface EthereumPublicKey {
  /** BIP32 public node */
  node: HDNodeType | undefined;
  /** serialized form of public node */
  xpub: string;
}

/**
 * Request: Ask device for Ethereum address corresponding to address_n path
 * @start
 * @next EthereumAddress
 * @next Failure
 */
export interface EthereumGetAddress {
  /** BIP-32 path to derive the key from master node */
  addressN: number[];
  /** optionally show on display before sending the result */
  showDisplay?: boolean | undefined;
  /** encoded Ethereum network, see ethereum-definitions.md for details */
  encodedNetwork?: Uint8Array | undefined;
  /** display the address in chunks of 4 characters */
  chunkify?: boolean | undefined;
}

/**
 * Response: Contains an Ethereum address derived from device private seed
 * @end
 */
export interface EthereumAddress {
  /**
   * trezor <1.8.0, <2.1.0 - raw bytes of Ethereum address
   *
   * @deprecated
   */
  OldAddress?: Uint8Array | undefined;
  /** Ethereum address as hex-encoded string */
  address?: string | undefined;
}

/**
 * Request: Ask device to sign transaction
 * gas_price, gas_limit and chain_id must be provided and non-zero.
 * All other fields are optional and default to value `0` if missing.
 * Note: the first at most 1024 bytes of data MUST be transmitted as part of this message.
 * @start
 * @next EthereumTxRequest
 * @next Failure
 */
export interface EthereumSignTx {
  /** BIP-32 path to derive the key from master node */
  addressN: number[];
  /** <=256 bit unsigned big endian */
  nonce?: Uint8Array | undefined;
  /** <=256 bit unsigned big endian (in wei) */
  gasPrice: Uint8Array;
  /** <=256 bit unsigned big endian */
  gasLimit: Uint8Array;
  /** recipient address */
  to?: string | undefined;
  /** <=256 bit unsigned big endian (in wei) */
  value?: Uint8Array | undefined;
  /** The initial data chunk (<= 1024 bytes) */
  dataInitialChunk?: Uint8Array | undefined;
  /** Length of transaction payload */
  dataLength?: number | undefined;
  /** Chain Id for EIP 155 */
  chainId: number;
  /** Used for Wanchain */
  txType?: number | undefined;
  /** network and/or token definitions for tx */
  definitions?: EthereumDefinitions | undefined;
  /** display the address in chunks of 4 characters */
  chunkify?: boolean | undefined;
}

/**
 * Request: Ask device to sign EIP1559 transaction
 * Note: the first at most 1024 bytes of data MUST be transmitted as part of this message.
 * @start
 * @next EthereumTxRequest
 * @next Failure
 */
export interface EthereumSignTxEIP1559 {
  /** BIP-32 path to derive the key from master node */
  addressN: number[];
  /** <=256 bit unsigned big endian */
  nonce: Uint8Array;
  /** <=256 bit unsigned big endian (in wei) */
  maxGasFee: Uint8Array;
  /** <=256 bit unsigned big endian (in wei) */
  maxPriorityFee: Uint8Array;
  /** <=256 bit unsigned big endian */
  gasLimit: Uint8Array;
  /** recipient address */
  to?: string | undefined;
  /** <=256 bit unsigned big endian (in wei) */
  value: Uint8Array;
  /** The initial data chunk (<= 1024 bytes) */
  dataInitialChunk?: Uint8Array | undefined;
  /** Length of transaction payload */
  dataLength: number;
  /** Chain Id for EIP 155 */
  chainId: number;
  /** Access List */
  accessList: EthereumSignTxEIP1559_EthereumAccessList[];
  /** network and/or token definitions for tx */
  definitions?: EthereumDefinitions | undefined;
  /** display the address in chunks of 4 characters */
  chunkify?: boolean | undefined;
}

export interface EthereumSignTxEIP1559_EthereumAccessList {
  address: string;
  storageKeys: Uint8Array[];
}

/**
 * Response: Device asks for more data from transaction payload, or returns the signature.
 * If data_length is set, device awaits that many more bytes of payload.
 * Otherwise, the signature_* fields contain the computed transaction signature. All three fields will be present.
 * @end
 * @next EthereumTxAck
 */
export interface EthereumTxRequest {
  /** Number of bytes being requested (<= 1024) */
  dataLength?: number | undefined;
  /** Computed signature (recovery parameter, limited to 27 or 28) */
  signatureV?: number | undefined;
  /** Computed signature R component (256 bit) */
  signatureR?: Uint8Array | undefined;
  /** Computed signature S component (256 bit) */
  signatureS?: Uint8Array | undefined;
}

/**
 * Request: Transaction payload data.
 * @next EthereumTxRequest
 */
export interface EthereumTxAck {
  /** Bytes from transaction payload (<= 1024 bytes) */
  dataChunk: Uint8Array;
}

/**
 * Request: Ask device to sign message
 * @start
 * @next EthereumMessageSignature
 * @next Failure
 */
export interface EthereumSignMessage {
  /** BIP-32 path to derive the key from master node */
  addressN: number[];
  /** message to be signed */
  message: Uint8Array;
  /** encoded Ethereum network, see ethereum-definitions.md for details */
  encodedNetwork?: Uint8Array | undefined;
  /** display the address in chunks of 4 characters */
  chunkify?: boolean | undefined;
}

/**
 * Response: Signed message
 * @end
 */
export interface EthereumMessageSignature {
  /** signature of the message */
  signature: Uint8Array;
  /** address used to sign the message */
  address: string;
}

/**
 * Request: Ask device to verify message
 * @start
 * @next Success
 * @next Failure
 */
export interface EthereumVerifyMessage {
  /** signature to verify */
  signature: Uint8Array;
  /** message to verify */
  message: Uint8Array;
  /** address to verify */
  address: string;
  /** display the address in chunks of 4 characters */
  chunkify?: boolean | undefined;
}

/**
 * Request: Ask device to sign hash of typed data
 * @start
 * @next EthereumTypedDataSignature
 * @next Failure
 */
export interface EthereumSignTypedHash {
  /** BIP-32 path to derive the key from master node */
  addressN: number[];
  /** Hash of domainSeparator of typed data to be signed */
  domainSeparatorHash: Uint8Array;
  /** Hash of the data of typed data to be signed (empty if domain-only data) */
  messageHash?: Uint8Array | undefined;
  /** encoded Ethereum network, see ethereum-definitions.md for details */
  encodedNetwork?: Uint8Array | undefined;
}

/**
 * Response: Signed typed data
 * @end
 */
export interface EthereumTypedDataSignature {
  /** signature of the typed data */
  signature: Uint8Array;
  /** address used to sign the typed data */
  address: string;
}

function createBaseEthereumGetPublicKey(): EthereumGetPublicKey {
  return { addressN: [], showDisplay: false };
}

export const EthereumGetPublicKey = {
  encode(
    message: EthereumGetPublicKey,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.addressN) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.showDisplay !== undefined && message.showDisplay !== false) {
      writer.uint32(16).bool(message.showDisplay);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumGetPublicKey {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumGetPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.addressN.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressN.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.showDisplay = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumGetPublicKey {
    return {
      addressN: globalThis.Array.isArray(object?.addressN)
        ? object.addressN.map((e: any) => globalThis.Number(e))
        : [],
      showDisplay: isSet(object.showDisplay)
        ? globalThis.Boolean(object.showDisplay)
        : false,
    };
  },

  toJSON(message: EthereumGetPublicKey): unknown {
    const obj: any = {};
    if (message.addressN?.length) {
      obj.addressN = message.addressN.map((e) => Math.round(e));
    }
    if (message.showDisplay !== undefined && message.showDisplay !== false) {
      obj.showDisplay = message.showDisplay;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumGetPublicKey>, I>>(
    base?: I,
  ): EthereumGetPublicKey {
    return EthereumGetPublicKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumGetPublicKey>, I>>(
    object: I,
  ): EthereumGetPublicKey {
    const message = createBaseEthereumGetPublicKey();
    message.addressN = object.addressN?.map((e) => e) || [];
    message.showDisplay = object.showDisplay ?? false;
    return message;
  },
};

function createBaseEthereumPublicKey(): EthereumPublicKey {
  return { node: undefined, xpub: "" };
}

export const EthereumPublicKey = {
  encode(
    message: EthereumPublicKey,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.node !== undefined) {
      HDNodeType.encode(message.node, writer.uint32(10).fork()).ldelim();
    }
    if (message.xpub !== "") {
      writer.uint32(18).string(message.xpub);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EthereumPublicKey {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.node = HDNodeType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.xpub = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumPublicKey {
    return {
      node: isSet(object.node) ? HDNodeType.fromJSON(object.node) : undefined,
      xpub: isSet(object.xpub) ? globalThis.String(object.xpub) : "",
    };
  },

  toJSON(message: EthereumPublicKey): unknown {
    const obj: any = {};
    if (message.node !== undefined) {
      obj.node = HDNodeType.toJSON(message.node);
    }
    if (message.xpub !== "") {
      obj.xpub = message.xpub;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumPublicKey>, I>>(
    base?: I,
  ): EthereumPublicKey {
    return EthereumPublicKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumPublicKey>, I>>(
    object: I,
  ): EthereumPublicKey {
    const message = createBaseEthereumPublicKey();
    message.node =
      object.node !== undefined && object.node !== null
        ? HDNodeType.fromPartial(object.node)
        : undefined;
    message.xpub = object.xpub ?? "";
    return message;
  },
};

function createBaseEthereumGetAddress(): EthereumGetAddress {
  return {
    addressN: [],
    showDisplay: false,
    encodedNetwork: new Uint8Array(0),
    chunkify: false,
  };
}

export const EthereumGetAddress = {
  encode(
    message: EthereumGetAddress,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.addressN) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.showDisplay !== undefined && message.showDisplay !== false) {
      writer.uint32(16).bool(message.showDisplay);
    }
    if (
      message.encodedNetwork !== undefined &&
      message.encodedNetwork.length !== 0
    ) {
      writer.uint32(26).bytes(message.encodedNetwork);
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      writer.uint32(32).bool(message.chunkify);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EthereumGetAddress {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumGetAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.addressN.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressN.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.showDisplay = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.encodedNetwork = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.chunkify = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumGetAddress {
    return {
      addressN: globalThis.Array.isArray(object?.addressN)
        ? object.addressN.map((e: any) => globalThis.Number(e))
        : [],
      showDisplay: isSet(object.showDisplay)
        ? globalThis.Boolean(object.showDisplay)
        : false,
      encodedNetwork: isSet(object.encodedNetwork)
        ? bytesFromBase64(object.encodedNetwork)
        : new Uint8Array(0),
      chunkify: isSet(object.chunkify)
        ? globalThis.Boolean(object.chunkify)
        : false,
    };
  },

  toJSON(message: EthereumGetAddress): unknown {
    const obj: any = {};
    if (message.addressN?.length) {
      obj.addressN = message.addressN.map((e) => Math.round(e));
    }
    if (message.showDisplay !== undefined && message.showDisplay !== false) {
      obj.showDisplay = message.showDisplay;
    }
    if (
      message.encodedNetwork !== undefined &&
      message.encodedNetwork.length !== 0
    ) {
      obj.encodedNetwork = base64FromBytes(message.encodedNetwork);
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      obj.chunkify = message.chunkify;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumGetAddress>, I>>(
    base?: I,
  ): EthereumGetAddress {
    return EthereumGetAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumGetAddress>, I>>(
    object: I,
  ): EthereumGetAddress {
    const message = createBaseEthereumGetAddress();
    message.addressN = object.addressN?.map((e) => e) || [];
    message.showDisplay = object.showDisplay ?? false;
    message.encodedNetwork = object.encodedNetwork ?? new Uint8Array(0);
    message.chunkify = object.chunkify ?? false;
    return message;
  },
};

function createBaseEthereumAddress(): EthereumAddress {
  return { OldAddress: new Uint8Array(0), address: "" };
}

export const EthereumAddress = {
  encode(
    message: EthereumAddress,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.OldAddress !== undefined && message.OldAddress.length !== 0) {
      writer.uint32(10).bytes(message.OldAddress);
    }
    if (message.address !== undefined && message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EthereumAddress {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.OldAddress = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumAddress {
    return {
      OldAddress: isSet(object.OldAddress)
        ? bytesFromBase64(object.OldAddress)
        : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: EthereumAddress): unknown {
    const obj: any = {};
    if (message.OldAddress !== undefined && message.OldAddress.length !== 0) {
      obj.OldAddress = base64FromBytes(message.OldAddress);
    }
    if (message.address !== undefined && message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumAddress>, I>>(
    base?: I,
  ): EthereumAddress {
    return EthereumAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumAddress>, I>>(
    object: I,
  ): EthereumAddress {
    const message = createBaseEthereumAddress();
    message.OldAddress = object.OldAddress ?? new Uint8Array(0);
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseEthereumSignTx(): EthereumSignTx {
  return {
    addressN: [],
    nonce: new Uint8Array(0),
    gasPrice: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    to: "",
    value: new Uint8Array(0),
    dataInitialChunk: new Uint8Array(0),
    dataLength: 0,
    chainId: 0,
    txType: 0,
    definitions: undefined,
    chunkify: false,
  };
}

export const EthereumSignTx = {
  encode(
    message: EthereumSignTx,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.addressN) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.nonce !== undefined && message.nonce.length !== 0) {
      writer.uint32(18).bytes(message.nonce);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(26).bytes(message.gasPrice);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(34).bytes(message.gasLimit);
    }
    if (message.to !== undefined && message.to !== "") {
      writer.uint32(90).string(message.to);
    }
    if (message.value !== undefined && message.value.length !== 0) {
      writer.uint32(50).bytes(message.value);
    }
    if (
      message.dataInitialChunk !== undefined &&
      message.dataInitialChunk.length !== 0
    ) {
      writer.uint32(58).bytes(message.dataInitialChunk);
    }
    if (message.dataLength !== undefined && message.dataLength !== 0) {
      writer.uint32(64).uint32(message.dataLength);
    }
    if (message.chainId !== 0) {
      writer.uint32(72).uint64(message.chainId);
    }
    if (message.txType !== undefined && message.txType !== 0) {
      writer.uint32(80).uint32(message.txType);
    }
    if (message.definitions !== undefined) {
      EthereumDefinitions.encode(
        message.definitions,
        writer.uint32(98).fork(),
      ).ldelim();
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      writer.uint32(104).bool(message.chunkify);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EthereumSignTx {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumSignTx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.addressN.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressN.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.to = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.value = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dataInitialChunk = reader.bytes();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.dataLength = reader.uint32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.txType = reader.uint32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.definitions = EthereumDefinitions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.chunkify = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumSignTx {
    return {
      addressN: globalThis.Array.isArray(object?.addressN)
        ? object.addressN.map((e: any) => globalThis.Number(e))
        : [],
      nonce: isSet(object.nonce)
        ? bytesFromBase64(object.nonce)
        : new Uint8Array(0),
      gasPrice: isSet(object.gasPrice)
        ? bytesFromBase64(object.gasPrice)
        : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit)
        ? bytesFromBase64(object.gasLimit)
        : new Uint8Array(0),
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
      dataInitialChunk: isSet(object.dataInitialChunk)
        ? bytesFromBase64(object.dataInitialChunk)
        : new Uint8Array(0),
      dataLength: isSet(object.dataLength)
        ? globalThis.Number(object.dataLength)
        : 0,
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      txType: isSet(object.txType) ? globalThis.Number(object.txType) : 0,
      definitions: isSet(object.definitions)
        ? EthereumDefinitions.fromJSON(object.definitions)
        : undefined,
      chunkify: isSet(object.chunkify)
        ? globalThis.Boolean(object.chunkify)
        : false,
    };
  },

  toJSON(message: EthereumSignTx): unknown {
    const obj: any = {};
    if (message.addressN?.length) {
      obj.addressN = message.addressN.map((e) => Math.round(e));
    }
    if (message.nonce !== undefined && message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.to !== undefined && message.to !== "") {
      obj.to = message.to;
    }
    if (message.value !== undefined && message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (
      message.dataInitialChunk !== undefined &&
      message.dataInitialChunk.length !== 0
    ) {
      obj.dataInitialChunk = base64FromBytes(message.dataInitialChunk);
    }
    if (message.dataLength !== undefined && message.dataLength !== 0) {
      obj.dataLength = Math.round(message.dataLength);
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.txType !== undefined && message.txType !== 0) {
      obj.txType = Math.round(message.txType);
    }
    if (message.definitions !== undefined) {
      obj.definitions = EthereumDefinitions.toJSON(message.definitions);
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      obj.chunkify = message.chunkify;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumSignTx>, I>>(
    base?: I,
  ): EthereumSignTx {
    return EthereumSignTx.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumSignTx>, I>>(
    object: I,
  ): EthereumSignTx {
    const message = createBaseEthereumSignTx();
    message.addressN = object.addressN?.map((e) => e) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.to = object.to ?? "";
    message.value = object.value ?? new Uint8Array(0);
    message.dataInitialChunk = object.dataInitialChunk ?? new Uint8Array(0);
    message.dataLength = object.dataLength ?? 0;
    message.chainId = object.chainId ?? 0;
    message.txType = object.txType ?? 0;
    message.definitions =
      object.definitions !== undefined && object.definitions !== null
        ? EthereumDefinitions.fromPartial(object.definitions)
        : undefined;
    message.chunkify = object.chunkify ?? false;
    return message;
  },
};

function createBaseEthereumSignTxEIP1559(): EthereumSignTxEIP1559 {
  return {
    addressN: [],
    nonce: new Uint8Array(0),
    maxGasFee: new Uint8Array(0),
    maxPriorityFee: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    to: "",
    value: new Uint8Array(0),
    dataInitialChunk: new Uint8Array(0),
    dataLength: 0,
    chainId: 0,
    accessList: [],
    definitions: undefined,
    chunkify: false,
  };
}

export const EthereumSignTxEIP1559 = {
  encode(
    message: EthereumSignTxEIP1559,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.addressN) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.nonce.length !== 0) {
      writer.uint32(18).bytes(message.nonce);
    }
    if (message.maxGasFee.length !== 0) {
      writer.uint32(26).bytes(message.maxGasFee);
    }
    if (message.maxPriorityFee.length !== 0) {
      writer.uint32(34).bytes(message.maxPriorityFee);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(42).bytes(message.gasLimit);
    }
    if (message.to !== undefined && message.to !== "") {
      writer.uint32(50).string(message.to);
    }
    if (message.value.length !== 0) {
      writer.uint32(58).bytes(message.value);
    }
    if (
      message.dataInitialChunk !== undefined &&
      message.dataInitialChunk.length !== 0
    ) {
      writer.uint32(66).bytes(message.dataInitialChunk);
    }
    if (message.dataLength !== 0) {
      writer.uint32(72).uint32(message.dataLength);
    }
    if (message.chainId !== 0) {
      writer.uint32(80).uint64(message.chainId);
    }
    for (const v of message.accessList) {
      EthereumSignTxEIP1559_EthereumAccessList.encode(
        v!,
        writer.uint32(90).fork(),
      ).ldelim();
    }
    if (message.definitions !== undefined) {
      EthereumDefinitions.encode(
        message.definitions,
        writer.uint32(98).fork(),
      ).ldelim();
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      writer.uint32(104).bool(message.chunkify);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumSignTxEIP1559 {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumSignTxEIP1559();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.addressN.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressN.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxGasFee = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maxPriorityFee = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.to = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.value = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dataInitialChunk = reader.bytes();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.dataLength = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.accessList.push(
            EthereumSignTxEIP1559_EthereumAccessList.decode(
              reader,
              reader.uint32(),
            ),
          );
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.definitions = EthereumDefinitions.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.chunkify = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumSignTxEIP1559 {
    return {
      addressN: globalThis.Array.isArray(object?.addressN)
        ? object.addressN.map((e: any) => globalThis.Number(e))
        : [],
      nonce: isSet(object.nonce)
        ? bytesFromBase64(object.nonce)
        : new Uint8Array(0),
      maxGasFee: isSet(object.maxGasFee)
        ? bytesFromBase64(object.maxGasFee)
        : new Uint8Array(0),
      maxPriorityFee: isSet(object.maxPriorityFee)
        ? bytesFromBase64(object.maxPriorityFee)
        : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit)
        ? bytesFromBase64(object.gasLimit)
        : new Uint8Array(0),
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      value: isSet(object.value)
        ? bytesFromBase64(object.value)
        : new Uint8Array(0),
      dataInitialChunk: isSet(object.dataInitialChunk)
        ? bytesFromBase64(object.dataInitialChunk)
        : new Uint8Array(0),
      dataLength: isSet(object.dataLength)
        ? globalThis.Number(object.dataLength)
        : 0,
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
      accessList: globalThis.Array.isArray(object?.accessList)
        ? object.accessList.map((e: any) =>
            EthereumSignTxEIP1559_EthereumAccessList.fromJSON(e),
          )
        : [],
      definitions: isSet(object.definitions)
        ? EthereumDefinitions.fromJSON(object.definitions)
        : undefined,
      chunkify: isSet(object.chunkify)
        ? globalThis.Boolean(object.chunkify)
        : false,
    };
  },

  toJSON(message: EthereumSignTxEIP1559): unknown {
    const obj: any = {};
    if (message.addressN?.length) {
      obj.addressN = message.addressN.map((e) => Math.round(e));
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.maxGasFee.length !== 0) {
      obj.maxGasFee = base64FromBytes(message.maxGasFee);
    }
    if (message.maxPriorityFee.length !== 0) {
      obj.maxPriorityFee = base64FromBytes(message.maxPriorityFee);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.to !== undefined && message.to !== "") {
      obj.to = message.to;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (
      message.dataInitialChunk !== undefined &&
      message.dataInitialChunk.length !== 0
    ) {
      obj.dataInitialChunk = base64FromBytes(message.dataInitialChunk);
    }
    if (message.dataLength !== 0) {
      obj.dataLength = Math.round(message.dataLength);
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    if (message.accessList?.length) {
      obj.accessList = message.accessList.map((e) =>
        EthereumSignTxEIP1559_EthereumAccessList.toJSON(e),
      );
    }
    if (message.definitions !== undefined) {
      obj.definitions = EthereumDefinitions.toJSON(message.definitions);
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      obj.chunkify = message.chunkify;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumSignTxEIP1559>, I>>(
    base?: I,
  ): EthereumSignTxEIP1559 {
    return EthereumSignTxEIP1559.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumSignTxEIP1559>, I>>(
    object: I,
  ): EthereumSignTxEIP1559 {
    const message = createBaseEthereumSignTxEIP1559();
    message.addressN = object.addressN?.map((e) => e) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.maxGasFee = object.maxGasFee ?? new Uint8Array(0);
    message.maxPriorityFee = object.maxPriorityFee ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.to = object.to ?? "";
    message.value = object.value ?? new Uint8Array(0);
    message.dataInitialChunk = object.dataInitialChunk ?? new Uint8Array(0);
    message.dataLength = object.dataLength ?? 0;
    message.chainId = object.chainId ?? 0;
    message.accessList =
      object.accessList?.map((e) =>
        EthereumSignTxEIP1559_EthereumAccessList.fromPartial(e),
      ) || [];
    message.definitions =
      object.definitions !== undefined && object.definitions !== null
        ? EthereumDefinitions.fromPartial(object.definitions)
        : undefined;
    message.chunkify = object.chunkify ?? false;
    return message;
  },
};

function createBaseEthereumSignTxEIP1559_EthereumAccessList(): EthereumSignTxEIP1559_EthereumAccessList {
  return { address: "", storageKeys: [] };
}

export const EthereumSignTxEIP1559_EthereumAccessList = {
  encode(
    message: EthereumSignTxEIP1559_EthereumAccessList,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.storageKeys) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumSignTxEIP1559_EthereumAccessList {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumSignTxEIP1559_EthereumAccessList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.storageKeys.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumSignTxEIP1559_EthereumAccessList {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      storageKeys: globalThis.Array.isArray(object?.storageKeys)
        ? object.storageKeys.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: EthereumSignTxEIP1559_EthereumAccessList): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.storageKeys?.length) {
      obj.storageKeys = message.storageKeys.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<
    I extends Exact<DeepPartial<EthereumSignTxEIP1559_EthereumAccessList>, I>,
  >(base?: I): EthereumSignTxEIP1559_EthereumAccessList {
    return EthereumSignTxEIP1559_EthereumAccessList.fromPartial(
      base ?? ({} as any),
    );
  },
  fromPartial<
    I extends Exact<DeepPartial<EthereumSignTxEIP1559_EthereumAccessList>, I>,
  >(object: I): EthereumSignTxEIP1559_EthereumAccessList {
    const message = createBaseEthereumSignTxEIP1559_EthereumAccessList();
    message.address = object.address ?? "";
    message.storageKeys = object.storageKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseEthereumTxRequest(): EthereumTxRequest {
  return {
    dataLength: 0,
    signatureV: 0,
    signatureR: new Uint8Array(0),
    signatureS: new Uint8Array(0),
  };
}

export const EthereumTxRequest = {
  encode(
    message: EthereumTxRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.dataLength !== undefined && message.dataLength !== 0) {
      writer.uint32(8).uint32(message.dataLength);
    }
    if (message.signatureV !== undefined && message.signatureV !== 0) {
      writer.uint32(16).uint32(message.signatureV);
    }
    if (message.signatureR !== undefined && message.signatureR.length !== 0) {
      writer.uint32(26).bytes(message.signatureR);
    }
    if (message.signatureS !== undefined && message.signatureS.length !== 0) {
      writer.uint32(34).bytes(message.signatureS);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EthereumTxRequest {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTxRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dataLength = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.signatureV = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signatureR = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signatureS = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTxRequest {
    return {
      dataLength: isSet(object.dataLength)
        ? globalThis.Number(object.dataLength)
        : 0,
      signatureV: isSet(object.signatureV)
        ? globalThis.Number(object.signatureV)
        : 0,
      signatureR: isSet(object.signatureR)
        ? bytesFromBase64(object.signatureR)
        : new Uint8Array(0),
      signatureS: isSet(object.signatureS)
        ? bytesFromBase64(object.signatureS)
        : new Uint8Array(0),
    };
  },

  toJSON(message: EthereumTxRequest): unknown {
    const obj: any = {};
    if (message.dataLength !== undefined && message.dataLength !== 0) {
      obj.dataLength = Math.round(message.dataLength);
    }
    if (message.signatureV !== undefined && message.signatureV !== 0) {
      obj.signatureV = Math.round(message.signatureV);
    }
    if (message.signatureR !== undefined && message.signatureR.length !== 0) {
      obj.signatureR = base64FromBytes(message.signatureR);
    }
    if (message.signatureS !== undefined && message.signatureS.length !== 0) {
      obj.signatureS = base64FromBytes(message.signatureS);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumTxRequest>, I>>(
    base?: I,
  ): EthereumTxRequest {
    return EthereumTxRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumTxRequest>, I>>(
    object: I,
  ): EthereumTxRequest {
    const message = createBaseEthereumTxRequest();
    message.dataLength = object.dataLength ?? 0;
    message.signatureV = object.signatureV ?? 0;
    message.signatureR = object.signatureR ?? new Uint8Array(0);
    message.signatureS = object.signatureS ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEthereumTxAck(): EthereumTxAck {
  return { dataChunk: new Uint8Array(0) };
}

export const EthereumTxAck = {
  encode(
    message: EthereumTxAck,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.dataChunk.length !== 0) {
      writer.uint32(10).bytes(message.dataChunk);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EthereumTxAck {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTxAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataChunk = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTxAck {
    return {
      dataChunk: isSet(object.dataChunk)
        ? bytesFromBase64(object.dataChunk)
        : new Uint8Array(0),
    };
  },

  toJSON(message: EthereumTxAck): unknown {
    const obj: any = {};
    if (message.dataChunk.length !== 0) {
      obj.dataChunk = base64FromBytes(message.dataChunk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumTxAck>, I>>(
    base?: I,
  ): EthereumTxAck {
    return EthereumTxAck.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumTxAck>, I>>(
    object: I,
  ): EthereumTxAck {
    const message = createBaseEthereumTxAck();
    message.dataChunk = object.dataChunk ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEthereumSignMessage(): EthereumSignMessage {
  return {
    addressN: [],
    message: new Uint8Array(0),
    encodedNetwork: new Uint8Array(0),
    chunkify: false,
  };
}

export const EthereumSignMessage = {
  encode(
    message: EthereumSignMessage,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.addressN) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.message.length !== 0) {
      writer.uint32(18).bytes(message.message);
    }
    if (
      message.encodedNetwork !== undefined &&
      message.encodedNetwork.length !== 0
    ) {
      writer.uint32(26).bytes(message.encodedNetwork);
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      writer.uint32(32).bool(message.chunkify);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EthereumSignMessage {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumSignMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.addressN.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressN.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.encodedNetwork = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.chunkify = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumSignMessage {
    return {
      addressN: globalThis.Array.isArray(object?.addressN)
        ? object.addressN.map((e: any) => globalThis.Number(e))
        : [],
      message: isSet(object.message)
        ? bytesFromBase64(object.message)
        : new Uint8Array(0),
      encodedNetwork: isSet(object.encodedNetwork)
        ? bytesFromBase64(object.encodedNetwork)
        : new Uint8Array(0),
      chunkify: isSet(object.chunkify)
        ? globalThis.Boolean(object.chunkify)
        : false,
    };
  },

  toJSON(message: EthereumSignMessage): unknown {
    const obj: any = {};
    if (message.addressN?.length) {
      obj.addressN = message.addressN.map((e) => Math.round(e));
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (
      message.encodedNetwork !== undefined &&
      message.encodedNetwork.length !== 0
    ) {
      obj.encodedNetwork = base64FromBytes(message.encodedNetwork);
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      obj.chunkify = message.chunkify;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumSignMessage>, I>>(
    base?: I,
  ): EthereumSignMessage {
    return EthereumSignMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumSignMessage>, I>>(
    object: I,
  ): EthereumSignMessage {
    const message = createBaseEthereumSignMessage();
    message.addressN = object.addressN?.map((e) => e) || [];
    message.message = object.message ?? new Uint8Array(0);
    message.encodedNetwork = object.encodedNetwork ?? new Uint8Array(0);
    message.chunkify = object.chunkify ?? false;
    return message;
  },
};

function createBaseEthereumMessageSignature(): EthereumMessageSignature {
  return { signature: new Uint8Array(0), address: "" };
}

export const EthereumMessageSignature = {
  encode(
    message: EthereumMessageSignature,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumMessageSignature {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumMessageSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumMessageSignature {
    return {
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: EthereumMessageSignature): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumMessageSignature>, I>>(
    base?: I,
  ): EthereumMessageSignature {
    return EthereumMessageSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumMessageSignature>, I>>(
    object: I,
  ): EthereumMessageSignature {
    const message = createBaseEthereumMessageSignature();
    message.signature = object.signature ?? new Uint8Array(0);
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseEthereumVerifyMessage(): EthereumVerifyMessage {
  return {
    signature: new Uint8Array(0),
    message: new Uint8Array(0),
    address: "",
    chunkify: false,
  };
}

export const EthereumVerifyMessage = {
  encode(
    message: EthereumVerifyMessage,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.message.length !== 0) {
      writer.uint32(26).bytes(message.message);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      writer.uint32(40).bool(message.chunkify);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumVerifyMessage {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumVerifyMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.chunkify = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumVerifyMessage {
    return {
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
      message: isSet(object.message)
        ? bytesFromBase64(object.message)
        : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      chunkify: isSet(object.chunkify)
        ? globalThis.Boolean(object.chunkify)
        : false,
    };
  },

  toJSON(message: EthereumVerifyMessage): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.chunkify !== undefined && message.chunkify !== false) {
      obj.chunkify = message.chunkify;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumVerifyMessage>, I>>(
    base?: I,
  ): EthereumVerifyMessage {
    return EthereumVerifyMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumVerifyMessage>, I>>(
    object: I,
  ): EthereumVerifyMessage {
    const message = createBaseEthereumVerifyMessage();
    message.signature = object.signature ?? new Uint8Array(0);
    message.message = object.message ?? new Uint8Array(0);
    message.address = object.address ?? "";
    message.chunkify = object.chunkify ?? false;
    return message;
  },
};

function createBaseEthereumSignTypedHash(): EthereumSignTypedHash {
  return {
    addressN: [],
    domainSeparatorHash: new Uint8Array(0),
    messageHash: new Uint8Array(0),
    encodedNetwork: new Uint8Array(0),
  };
}

export const EthereumSignTypedHash = {
  encode(
    message: EthereumSignTypedHash,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.addressN) {
      writer.uint32(v);
    }
    writer.ldelim();
    if (message.domainSeparatorHash.length !== 0) {
      writer.uint32(18).bytes(message.domainSeparatorHash);
    }
    if (message.messageHash !== undefined && message.messageHash.length !== 0) {
      writer.uint32(26).bytes(message.messageHash);
    }
    if (
      message.encodedNetwork !== undefined &&
      message.encodedNetwork.length !== 0
    ) {
      writer.uint32(34).bytes(message.encodedNetwork);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumSignTypedHash {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumSignTypedHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.addressN.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressN.push(reader.uint32());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.domainSeparatorHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messageHash = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.encodedNetwork = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumSignTypedHash {
    return {
      addressN: globalThis.Array.isArray(object?.addressN)
        ? object.addressN.map((e: any) => globalThis.Number(e))
        : [],
      domainSeparatorHash: isSet(object.domainSeparatorHash)
        ? bytesFromBase64(object.domainSeparatorHash)
        : new Uint8Array(0),
      messageHash: isSet(object.messageHash)
        ? bytesFromBase64(object.messageHash)
        : new Uint8Array(0),
      encodedNetwork: isSet(object.encodedNetwork)
        ? bytesFromBase64(object.encodedNetwork)
        : new Uint8Array(0),
    };
  },

  toJSON(message: EthereumSignTypedHash): unknown {
    const obj: any = {};
    if (message.addressN?.length) {
      obj.addressN = message.addressN.map((e) => Math.round(e));
    }
    if (message.domainSeparatorHash.length !== 0) {
      obj.domainSeparatorHash = base64FromBytes(message.domainSeparatorHash);
    }
    if (message.messageHash !== undefined && message.messageHash.length !== 0) {
      obj.messageHash = base64FromBytes(message.messageHash);
    }
    if (
      message.encodedNetwork !== undefined &&
      message.encodedNetwork.length !== 0
    ) {
      obj.encodedNetwork = base64FromBytes(message.encodedNetwork);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumSignTypedHash>, I>>(
    base?: I,
  ): EthereumSignTypedHash {
    return EthereumSignTypedHash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumSignTypedHash>, I>>(
    object: I,
  ): EthereumSignTypedHash {
    const message = createBaseEthereumSignTypedHash();
    message.addressN = object.addressN?.map((e) => e) || [];
    message.domainSeparatorHash =
      object.domainSeparatorHash ?? new Uint8Array(0);
    message.messageHash = object.messageHash ?? new Uint8Array(0);
    message.encodedNetwork = object.encodedNetwork ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEthereumTypedDataSignature(): EthereumTypedDataSignature {
  return { signature: new Uint8Array(0), address: "" };
}

export const EthereumTypedDataSignature = {
  encode(
    message: EthereumTypedDataSignature,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): EthereumTypedDataSignature {
    const reader =
      input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEthereumTypedDataSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EthereumTypedDataSignature {
    return {
      signature: isSet(object.signature)
        ? bytesFromBase64(object.signature)
        : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: EthereumTypedDataSignature): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EthereumTypedDataSignature>, I>>(
    base?: I,
  ): EthereumTypedDataSignature {
    return EthereumTypedDataSignature.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EthereumTypedDataSignature>, I>>(
    object: I,
  ): EthereumTypedDataSignature {
    const message = createBaseEthereumTypedDataSignature();
    message.signature = object.signature ?? new Uint8Array(0);
    message.address = object.address ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
